* Mac Config

  I care about how my computer is configured.

  I like being able to magnify my screen so that I can easily show
  things to my daughter.

  I like being able to control what I am working with, and focus on it
  or dismiss it without much effort.

  There are certain programs I know how to use, and I'd like them to
  be present.

  And so I've put some time into thinking about how to configure my
  setup, and this is what I've come up with.

** What is this?

   As I am typing this, I am writing plain text in a single file named
   =README.org=. However, this single file is versatile.

   On one hand, it is part of a larger collection of files at
   https://github.com/jedcn/mac-config, and this means a formatted,
   web accessible copy is available here: [[https://github.com/jedcn/mac-config/blob/master/README.org.][README.org]].

   But, this file also contains chunks of computer code, and these
   chunks can be extracted into distinct files. In turn, these files
   play one of three roles:

   1. Some of the files contain HTML and serve as the basis of
      https://jedcn.github.io/mac-config.
   2. Some of the files contain configuration in a language called
      [[http://puppetlabs.com][puppet]]. These can be used within a framework named [[https://boxen.github.com][boxen]], and
      literally *are declarations* that can change my computer's
      configuration as a result of running a command.
   3. Some of the files contain helper code in a language called [[http://en.wikipedia.org/wiki/Ruby_(programming_language)][ruby]],
      and these glue things together by extracting code, building up
      the website, etc.

** Wait, what's =.org=?

   *This* is a file named =README.org=. That extension, =.org=, means
   that this is a plain text file that is structured following the
   conventions of [[http://en.wikipedia.org/wiki/Org-mode][org-mode]].

   A component of org-mode, named [[http://orgmode.org/worg/org-contrib/babel/][babel]], serves as the basis for
   interspersing chunks of code with text, and allowing these chunks
   to be extracted.

   If this seems strange to you, it probably is. From the meta point
   of view, *this* is an experiment using [[http://en.wikipedia.org/wiki/Literate_programming][Literate Programming]] to
   describe how I configure my computer.

   Why document configuration at all? It comes from the tension
   between these two ideas:

   1. I rarely configure a new computer, and yet,
   2. I deeply care about how my computer is configured.

   The core motivation for documenting this in the Literate Style
   stems from wanting to capture prose descriptions (with links and
   such) side-by-side my boxen configuration.

   It is also motivated by the idea that I am sometimes asked, "How
   did you configure your computer to do such-and-such?"

   The neat trick about Literate Source is that it can be made dense
   enough to create more than one artifact. This file *is* the puppet
   configuration *and* it *is* the website.

   Why not make it so that a single document can help me share with
   people?

** Who is this for?

   TODO

** Overview

  The point of this system is that you can reduce the setup time for a
  new MacOS machine to ~30 minutes and running a few commands.

  Once complete, you'll have:

  1. Applications installed (such as Chrome, Firefox)
  2. Homebrew utilities installed
  3. Dotfiles cloned and linked
  4. Git configured
  5. OSX configured (bind capslock to control, auto-hide the dock,
     screen zoom, fast key repeat, etc)
  6. Ruby and Node installations

  This works for me, and enables me to have things "just the way I
  want them" without having to maintain a list of instructions so that
  I can remember how they got that way.

  This repository is a fork of [[https://github.com/boxen/our-boxen][boxen/our-boxen]], and has been renamed
  to "my-boxen" because it's just for me.

  As a caveat, I am new to boxen: I don't know how this will play out
  over the months and years to come.

  I have created a Resources section at the bottom of this document
  that details websites, articles, and repositories I read through
  while getting this going.

** Commands

*** New Machine

    The commands you'd run on a fresh Mac are:

    #+BEGIN_SRC sh
      xcode-select --install
      sudo mkdir -p /opt/boxen
      sudo chown ${USER}:staff /opt/boxen
      git clone https://github.com/jedcn/my-boxen /opt/boxen/repo
      /opt/boxen/repo/script/boxen
    #+END_SRC

    These commands:

    1. Install xcode (which gets you a compiler: gcc)
    2. Clone my-boxen configuration to /opt/boxen/repo
    3. Invoke boxen which reads my-boxen configuration and sets up the
       machine.

*** Existing Machine

    If you've already setup your Mac, you can change your boxen
    configuration and run =boxen= to see those changes realized. This
    can be completed in as short as 10 seconds.

** Files

   Whenever you run =boxen= the configuration from certain files is
   applied. These files are all puppet files. An explanation and
   manifest follows.

*** jedcn.pp

    I start with a single puppet file: =jedcn.pp=.

    This file declares =people::jedcn=. This knows how to include
    everything, but doesn't know anything on its own.

    #+BEGIN_SRC puppet :tangle ./modules/people/manifests/jedcn.pp :padline no
      class people::jedcn {
        include people::jedcn::applications
        include people::jedcn::git
        include people::jedcn::homebrew
        include people::jedcn::links
        include people::jedcn::osx_config
        include people::jedcn::repositories
      }
    #+END_SRC

*** applications.pp

    This file declares =people::jedcn::applications=.

    This pulls in the non-homebrew applications that I use.

**** Applications

     I use the standard browsers, and I use Slate for Window
     Management.

     I found that I had to manually launch slate and allow it access
     to control my accessibility devices. This was a matter of
     following prompts.

     I tried getting onepassword here (with [[https://github.com/boxen/puppet-onepassword][puppet-onepassword]]), but I
     couldn't figure out the licensing. Specifically, after a boxen
     run it was in trial mode and looking for a license file. As far
     as I remember, I didn't have a license file because I originally
     bought 1Password through the AppStore. When I went through the
     AppStore, things worked just fine and so here's where I've ended
     up.

     Near as I can tell, if you try to get something running with
     boxen and then you give up and remove the puppetry, you can
     manually remove the application but you should also remove
     something called a receipt that can be found in the =/var/db=
     directory, for example:

     + =sudo rm .puppet_compressed_app_installed_1Password\ 5=
     + =sudo rm /var/db/.puppet_appdmg_installed_LittleSnitch=

     I learned this in the [[https://github.com/boxen/our-boxen/blob/master/docs/faq.md][official boxen FAQ]].

     #+BEGIN_SRC puppet :tangle ./modules/people/manifests/jedcn/applications.pp :padline no
       class people::jedcn::applications {
         include chrome
         include chrome::canary
         include firefox
         include slate
       }
     #+END_SRC

*** git.pp

    This file declares =people::jedcn::git=.

    This class calls out my git configuration.

    #+BEGIN_SRC puppet :tangle ./modules/people/manifests/jedcn/git.pp :padline no
      class people::jedcn::git {
        git::config::global { 'core.editor':
          value  => '/opt/boxen/homebrew/bin/emacsclient'
        }
      }
    #+END_SRC

*** homebrew.pp

    This file declares =people::jedcn::homebrew=.

    This class calls out all of the package I install from [[http://brew.sh][homebrew]].

    Homebrew is the standard package provider for puppetry within
    boxen.

    The majority of packages are simple, standard installs. It's like
    you typed =brew install ag=, for example.

    I install emacs with options certain options that I learned of in a
    post titled [[http://emacsredux.com/blog/2013/08/21/color-themes-redux/][Color Themes: Redux]] in [[ttp://emacsredux.com][Emacs Redux]].

    #+BEGIN_SRC puppet :tangle ./modules/people/manifests/jedcn/homebrew.pp :padline no
      class people::jedcn::homebrew {
        $homebrew_packages = [
                              'ag',
                              'tmux',
                              'tree',
                              'wget',
                              'zsh',
                              ]

        package { $homebrew_packages: }

        package { 'cask':
          ensure  => present,
          require => Package['emacs'],
        }

        package { 'emacs':
          ensure          => present,
          install_options => [
            '--cocoa',
            '--srgb'
          ],
        }
      }
    #+END_SRC
*** links.pp

    This file declares =people::jedcn::links=.

    This class creates symbolic links to various dotfiles.

    #+BEGIN_SRC puppet :tangle ./modules/people/manifests/jedcn/links.pp :padline no
      class people::jedcn::links {

        $my_init_src = '/opt/init-src'

        file { "/Users/${luser}/.zshrc":
          ensure  => link,
          mode    => '0644',
          target  => "${my_init_src}/dot-org-files/home/.zshrc",
          require => Repository["${my_init_src}/dot-org-files"],
        }

        file { "/Users/${luser}/.oh-my-zsh":
          ensure  => link,
          target  => "${my_init_src}/oh-my-zsh",
          require => Repository["${my_init_src}/oh-my-zsh"],
        }

        file { "/Users/${luser}/.slate":
          ensure  => link,
          mode    => '0644',
          target  => "${my_init_src}/dot-org-files/home/.slate",
          require => Repository["${my_init_src}/dot-org-files"],
        }
      }
    #+END_SRC

*** osx_config.pp

    This file declares =people::jedcn::osx_config=.

    This class sets my OSX configuration.

    Without boxen, these would be set by hand tweaking panels
    underneath System Preferences and editing various files.

    The following is achieved:

    1. zsh, installed via homebrew, is set as my default shell.
    2. The dock is configured to automatically hide.
    3. The dock is configured to only contain apps that are running.
    4. Holding CTRL and scrolling on trackpad will now magnify the
       screen.
    5. The speed at which keys "repeat" when they are pressed is
       significantly increased.
    6. The capslock key is configured to act like control.

    I found it very helpful to review [[https://github.com/boxen/puppet-osx][the main README of the
    puppet-osx]] project to understand these settings.

    #+BEGIN_SRC puppet :tangle ./modules/people/manifests/jedcn/osx_config.pp :padline no
      class people::jedcn::osx_config {

        # ZSH
        osx_chsh { $::luser:
          shell   => '/opt/boxen/homebrew/bin/zsh',
          require => Package['zsh'],
        }

        file_line { 'add zsh to /etc/shells':
          path    => '/etc/shells',
          line    => "${boxen::config::homebrewdir}/bin/zsh",
          require => Package['zsh'],
        }

        # Dock Settings
        include osx::dock::autohide
        include osx::dock::clear_dock

        # Screen Zoom
        include osx::universal_access::ctrl_mod_zoom
        include osx::universal_access::enable_scrollwheel_zoom

        # Key Repeat
        class { 'osx::global::key_repeat_delay':
          delay => 10
        }
        include osx::global::key_repeat_rate

        # Capslock becomes Control
        include osx::keyboard::capslock_to_control

        # Hot Corners
        osx::dock::hot_corner { 'Show the desktop':
          position => 'Bottom Right',
          action => 'Desktop'
        }
        osx::dock::hot_corner { 'Put Display to Sleep':
          position => 'Bottom Left',
          action => 'Put Display to Sleep'
        }

        # Recovery Message
        $recovery_owner = "This computer belongs to Jed Northridge."
        $recovery_contact = "If found, please contact jedcn@jedcn.com or 305-985-3326."
        osx::recovery_message { "${recovery_owner} ${recovery_contact}": }
      }
    #+END_SRC

*** repositories.pp

    This file declares =people::jedcn::repositories=.

    This class causes a directory to come into existence and several
    repositories to be cloned underneath that directory.

    The repositories involved are concerned with system scripts,
    configuration, and dotfiles.

    These repositories are necessary for bootstrapping. They lay down
    a solid foundation for work to begin upon.

    I will keep non-system repositories at another location, and I do
    not expect to manage them with boxen.

    #+BEGIN_SRC puppet :tangle ./modules/people/manifests/jedcn/repositories.pp :padline no
      class people::jedcn::repositories {

        $my_init_src = '/opt/init-src'

        file { $my_init_src:
          ensure => directory,
          mode   => 0644,
        }

        repository { "${my_init_src}/dot-org-files":
          source  => 'jedcn/dot-org-files',
          require => File[$my_init_src]
        }

        repository { "${my_init_src}/emacs-setup":
          source  => 'jedcn/emacs-setup',
          require => File[$my_init_src]
        }

        repository { "${my_init_src}/z":
          source  => 'rupa/z',
          require => File[$my_init_src]
        }

        repository { "${my_init_src}/oh-my-zsh":
          source  => 'robbyrussell/oh-my-zsh',
          require => File[$my_init_src]
        }
      }

    #+END_SRC

** Resources

   My main resource was Gary Larizza's article called "[[http://garylarizza.com/blog/2013/02/15/puppet-plus-github-equals-laptop-love/][Puppet + Github
   = Laptop <3]]" and [[https://github.com/glarizza/my-boxen/][glarizza/my-boxen]].

   Other resources included:

   + The official boxen homepage: https://boxen.github.com
   + [[https://github.com/boxen/our-boxen][boxen/our-boxen]]
   + Visiting https://github.com/boxen/ and then filtering through all
     of the puppet-* projects.
   + http://jjasghar.github.io/blog/2014/01/01/customizing-boxen/

** Ruby and Content Extraction

   This single =.org= file can be extracted into many component
   pieces. This is powered by Emacs and Ruby.

   Some of these pieces are puppetry and some are web files. The two
   main categories are presently:

   + *.pp extraction (for boxen runs)
   + HTML extraction (for building a static, descriptive site)

   As far as Ruby is concerned, the main driver is Rake. And so,
   there's a =Rakefile= and the are supporting =./rakelib/*.rake=

** Rake Basics

   One role played by this file is simple existence: so long as it
   exists, even if it contains no content, the =rake= command can find
   a home and understand the location of =./rakelib=.

   Another role is that it defines common functionality for running
   tasks and a default task.

#+BEGIN_SRC ruby :tangle ./Rakefile :padline no
  def run(c)
    require 'open3'
    _stdin, stdout, stderr = Open3.popen3(c)
    [ stdout.gets, stderr.gets, $?.to_i ]
  end

  task :emacs_installed do
    location = `which emacs`
    raise 'Unable to find emacs' if location.empty?
  end

  task default: :tangle
#+END_SRC

** Website

   This document can be unpacked into distinct puppet files that serve
   as configuration. It can also be unpacked into HTML files and Rake
   configuration builds and serves as a website.

   Those files are:

*** rakelib/index.html.erb

    This content started as the index.html associated with the
    Bootstrap version of [[http://html5boilerplate.com/][HTML5BoilerPlate]]. I removed the core content
    and replaced it with ERB. I also added a link to prism.js and css.

#+BEGIN_SRC html :tangle ./rakelib/index.html.erb :padline no
  <!DOCTYPE html>
  <!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
  <!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
  <!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
  <!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
      <head>
          <meta charset="utf-8">
          <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
          <title>My Boxen</title>
          <meta name="description" content="">
          <meta name="viewport" content="width=device-width, initial-scale=1">

          <link rel="stylesheet" href="css/bootstrap.min.css">
          <style>
              body {
                  padding-top: 50px;
                  padding-bottom: 20px;
              }
          </style>
          <link rel="stylesheet" href="css/bootstrap-theme.min.css">
          <link rel="stylesheet" href="css/prism.css">
          <link rel="stylesheet" href="css/main.css">

          <script src="js/vendor/modernizr-2.6.2-respond-1.1.0.min.js"></script>
          <script src="js/vendor/prism.js"></script>
      </head>
      <body>
          <!--[if lt IE 7]>
              <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
          <![endif]-->

      <div class="container">

        <%= content %>

        <hr>

        <footer>
          <p>:)</p>
        </footer>
      </div> <!-- /container -->
      </body>
  </html>
#+END_SRC

*** rakelib/ghpages.rake

    This file contains Rake-based instructions for building up static
    web content that serves as a website.

    This static content will be hosted on Github Pages, and so, the
    following makes it so that the directory =gh-pages/= is created
    and the contents of that directory are a single branch from this
    same repository.

    There's also a part that knows about http://www.initializr.com,
    and how to download a copy of HTML5 Boiler Plate. This comes in a
    ZIP. These instructions know how to unpack the ZIP and put parts
    of it in the right places.

    Finally there's a part in here that knows how to extract this
    =.org= file using emacs into HTML and then insert that HTML into
    an ERB enhanced template.

#+BEGIN_SRC ruby :tangle ./rakelib/ghpages.rake :padline no
  require 'rake/clean'

  desc 'Create Github Pages content'
  task 'build-gh-pages' => [ 'gh-pages',
                             'gh-pages-supporting-content',
                             'gh-pages/index.html' ]

  #
  # Setup ./gh-pages as a git clone with gh-pages checked out.
  #
  directory 'gh-pages' do
    repo = 'https://github.com/jedcn/my-boxen.git'
    branch = 'gh-pages'
    dir = branch
    args = "#{repo} --branch #{branch} --single-branch ./#{dir}"
    command = "git clone #{args}"
    stdout, stderr, _status = run(command)
    puts stderr, stdout
  end

  #
  # Extract supporting content from HTML5BoilerPlate
  #
  task 'gh-pages-supporting-content' => [ 'gh-pages/favicon.ico',
                                          'gh-pages/css/bootstrap.min.css',
                                          'gh-pages/css/bootstrap-theme.min.css',
                                          'gh-pages/js/vendor/modernizr-2.6.2-respond-1.1.0.min.js' ]

  def add_option(url, s)
    "#{url}&#{s}"
  end

  CLEAN.include('gh-pages/initializr.zip')
  CLEAN.include('gh-pages/initializr')
  file 'gh-pages/initializr' do
    chdir('gh-pages') do
      `wget -O initializr.zip 'http://www.initializr.com/builder?boot-hero&jquerymin&h5bp-iecond&h5bp-chromeframe&h5bp-analytics&h5bp-favicon&h5bp-appletouchicons&modernizrrespond&izr-emptyscript&boot-css&boot-scripts'`
      `unzip initializr.zip`
    end
  end

  #
  # Setup files from HTML5BoilerPlate
  #
  def cp_from_initializr(file, dir)
    dest =
      if dir
        "gh-pages/#{dir}"
      else
        'gh-pages'
      end
    FileUtils.cp("gh-pages/initializr/#{file}", dest, verbose: true)
  end

  file 'gh-pages/favicon.ico' => 'gh-pages/initializr' do
    cp_from_initializr('favicon.ico')
  end

  directory 'gh-pages/css' => 'gh-pages'
  directory 'gh-pages/js' => 'gh-pages'
  directory 'gh-pages/js/vendor' => 'gh-pages/js'

  file 'gh-pages/favicon.ico' => 'gh-pages/initializr' do
    cp_from_initializr('favicon.ico')
  end

  file 'gh-pages/css/bootstrap.min.css' => 'gh-pages/css' do
    cp_from_initializr('css/bootstrap.min.css', 'css')
  end

  file 'gh-pages/css/bootstrap-theme.min.css' => 'gh-pages/css' do
    cp_from_initializr('css/bootstrap-theme.min.css', 'css')
  end

  file 'gh-pages/js/vendor/modernizr-2.6.2-respond-1.1.0.min.js' =>
       'gh-pages/js/vendor' do
    cp_from_initializr('js/vendor/modernizr-2.6.2-respond-1.1.0.min.js',
                       'js/vendor')
  end

  directory 'gh-pages/css' => 'gh-pages'

  file 'README.html' => :emacs_installed do
    export_html_using_emacs('README.org')
  end

  file 'gh-pages/index.html' => [ 'gh-pages', 'README.html' ] do

    require 'erb'
    require 'ostruct'

    class ContentWrapper < OpenStruct
      def render(template)
        ERB.new(template).result(binding)
      end
    end

    template = File.read('rakelib/index.html.erb')

    content = File.read('README.html')

    cw = ContentWrapper.new({ content: content })
    File.open('gh-pages/index.html', 'w') do |file|
      file.write(cw.render(template))
    end

    rendered = File.read('gh-pages/index.html')
    s = "<pre>\n<code class='language-ruby'>"
    rendered = rendered.gsub('<pre class="src src-puppet">', s)
    rendered = rendered.gsub('</pre>', '</code></pre>')
    File.open('gh-pages/index.html', 'w') do |file|
      file.write(rendered)
    end
    rm 'README.html', verbose: true
  end

  def export_html_using_emacs(file)
    args = '--no-init-file --no-site-file --batch'
    tangle_elisp =
      %Q|(progn (require 'org) (find-file (expand-file-name \\"#{file}\\" \\"`pwd`\\")) (org-html-export-to-html nil nil nil t))|
    command = %Q|emacs #{args} --eval "#{tangle_elisp}"|
    stdout, stderr, _status = run(command)
    puts stderr
    puts stdout
  end
#+END_SRC

** Tangling Puppet

   A series of puppet files can be extracted from this document. This
   works by invoking emacs in batch mode. Some small emacs lisp is
   passed in via the command line, and that emacs lisp works with
   org-babel to extract files in place.

#+BEGIN_SRC ruby :tangle ./rakelib/tangle.rake :padline no
  def tangle_file_using_emacs(file)
    args = '--no-init-file --no-site-file --batch'
    tangle_elisp =
      %Q|(progn (require 'ob-tangle) (org-babel-tangle-file \\"#{file}\\"))|
    command = %Q|emacs #{args} --eval "#{tangle_elisp}"|
    _stdout, stderr, status = run(command)
    puts stderr unless status == 0
  end

  desc 'tangle literate source into puppet'
  task :tangle => :emacs_installed do
    tangle_file_using_emacs('README.org')
  end
#+END_SRC

** Staying up-to-date with boxen/our-boxen

   This repository is a fork of [[https://github.com/boxen/our-boxen][boxen/our-boxen]], and so, while I've
   done a bunch of customization, I'd like to stay up-to-date with the
   original repository to get fixes, security patches, etc.

   This is setup by creating a remote named "upstream" that points to
   [[https://github.com/boxen/our-boxen][boxen/our-boxen]]. Then the master branch from this repo is merged in
   like regular.

   The directions are here: [[https://help.github.com/articles/syncing-a-fork/][github.com/articles/syncing-a-fork/]].
** Manual Installs

   I installed the following Software manually:

*** 1Password

    I got this from the AppStore. I did because I couldn't figure out
    how to license it, otherwise.

*** Little Snitch

    I tried installing this via puppet. I tried a provider of =appdmg=
    and =pkgdmg=, and neither did I was expected. I started with
    =appdmg=, and this put both the Installer and Uninstaller in my
    Applications-- but that's not what I want. I want to run the
    Installer *once* and then have "Little Snitch Configuration" be
    the only thing that's in my Applications.

    Anyway-- I gave up and I downloaded it from this URL and
    double-clicked to the install:

    http://www.obdev.at/downloads/littlesnitch/LittleSnitch-3.5.1.dmg

    The install required a reboot, and after that, it immediately
    started going.
