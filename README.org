* Mac Config

** Introduction

   I care about how my computer is configured.

   I like magnifying any part of my screen so that I can easily show
   things to my daughter.

   I like controlling the applications that I am working with. I like
   being able to easily expand, shrink, or dismiss them without much
   effort.

   There are certain programs I know how to use, and I'd like them to
   automatically installed if they aren't.

   And so, I've put some time into thinking about how to configure my
   setup. This is what I've come up with.

*** What is this?

    As I am typing this, I am writing plain text in a single file
    named =README.org=. However, this single file is versatile.

    On one hand, it is part of a larger collection of files at
    https://github.com/jedcn/mac-config, and this means a formatted,
    web accessible version of this single file is available here:
    [[https://github.com/jedcn/mac-config/blob/master/README.org][README.org]].

    But, this file also contains chunks of computer code, and these
    chunks can be extracted into distinct files. These files play one
    of three roles:

    1. Some of the files contain HTML and serve as the basis of a
       simple "website:" https://jedcn.github.io/mac-config.
    2. Some of the files contain configuration in a language called
       [[http://puppetlabs.com][puppet]]. These play a role within a framework named [[https://boxen.github.com][boxen]], and
       *are declarations* that can change my computer's configuration
       as a result of running a command.
    3. Some of the files contain helper code in a language called [[http://en.wikipedia.org/wiki/Ruby_(programming_language)][ruby]],
       and these glue things together by extracting code, building up
       the website, etc.

*** Wait, what's =.org=?

    *This* is a file named =README.org=. That extension, =.org=, means
    that this is a plain text file that is structured following the
    conventions of [[http://en.wikipedia.org/wiki/Org-mode][org-mode]], finally, org-mode is a part of [[https://www.gnu.org/software/emacs/][emacs]].

    A component of org-mode, named [[http://orgmode.org/worg/org-contrib/babel/][babel]], serves as the basis for
    interspersing chunks of code with text, and allowing these chunks
    to be extracted.

    If this seems strange to you, it probably is. From the meta point
    of view, *this* is an experiment in using [[http://en.wikipedia.org/wiki/Literate_programming][Literate Programming]] to
    describe how I configure my computer.

    Why document computer configuration at all? It stems from tension
    between these two ideas:

    1. I rarely configure a new computer, and yet,
    2. I deeply care about how my computer is configured.

    The core motivation for documenting this in a Literate System
    stems from wanting to capture prose descriptions (with links and
    such) side-by-side my boxen configuration.

    It is also motivated by the idea that I am sometimes asked, "How
    did you configure your computer to do such-and-such?" I don't have
    a great memory so I'd benefit from a self-describing
    configuration.

    The neat trick about Literate Source is that it can be dense
    enough to create more than one artifact. This file *is* the puppet
    configuration and it *is* the website and it *is* the glue code
    that puts everything together.

    So, why not make it so that a single document can help me share
    with people?

*** Who is this for?

    I hope most of my prose configuration descriptions are accessible
    to all mac users.

    When it comes to boxen and puppet, what I have here works but I'm
    not an expert by any means. If you've never seen a boxen
    configuration before, you can surely see it here and see how
    things are laid out.

*** Who uses this?

    I am the only explicit user of this configuration. I use it
    outside of the context of any group or company, and I only have a
    single computer.

    Having worked with boxen for a small bit now, I think it's all
    about [[https://en.wikipedia.org/wiki/Metcalfe's_law][Metcalfe's Law]] in the context of how many users and
    computers you're working with. The more of either one you have the
    more useful boxen will be.

    And so, when it's just me, or just you, *I'd think twice about
    using boxen itself.*

    When it comes to this particular config, I can see how someone
    could get an idea for what boxen is from it, or perhaps copy and
    paste a few snippets into theirs.

    However, no one should clone or fork this repository. Instead, if
    you're looking to get started with boxen, then you should fork
    [[https://github.com/boxen/our-boxen][boxen/our-boxen]].

*** Agenda

    We've got a general introduction to this document, and we
    understand how it can be used, so what's left?

    We'll lay things out as follows:

    1. General Introduction (this)
    2. OSX Settings
    3. Dotfiles and Repositories
    4. Applications
    5. Command Line Utilities

    As we cover the content above, we'll intertwine prose with
    puppetry (the language of boxen). The intent is to go straight at
    what we're trying to achieve, and then, once we know where we want
    to get to, we'll see how things fit together within the boxen
    framework.

    There's a bunch of mechanics underneath it all, and once this main
    content has been covered, we'll move onto several supplementary
    concepts:

    1. Boxen, Puppetry, and File Layout
    2. How to Get Started with boxen
    3. Glue Code and Rake Tasks
    4. Keeping Things Up To Date

** OSX Settings

   I've started with the idea of configuring OSX because I think it's
   the most compelling reason for using boxen. I can imagine a
   situation where I use boxen *just* for the ability to automatically
   configure OSX, and nothing more.

   That said, boxen itself doesn't know about OSX, but you can use a
   module named [[https://github.com/boxen/puppet-osx][puppet-osx]], and it provides the ability to do things
   like:

   1. Map CAPS LOCK to CTRL.
   2. Make your key presses repeat very quickly.
   3. Make it so that holding CTRL and scrolling on your trackpad will
      magnify the screen underneath the mouse pointer.
   4. Switch your shell to ZSH.
   5. Automatically hide the dock.
   6. Remove clutter from the dock by making it only contain running
      apps.
   7. Setup a message on your lock screen to provides your contact
      information if your laptop is found.

   All of these things are tweakable by hand, but using boxen lets you
   get going in a flash, and lets you change things (say, the repeat
   rate) in a controlled manner.

   If you're working in this area, [[https://github.com/boxen/puppet-osx][the main README of the puppet-osx]]
   project is critical to understanding these settings.

   #+BEGIN_SRC puppet :tangle ./modules/people/manifests/jedcn/osx_config.pp
     class people::jedcn::osx_config {

       # ZSH
       osx_chsh { $::luser:
         shell   => '/opt/boxen/homebrew/bin/zsh',
         require => Package['zsh'],
       }

       file_line { 'add zsh to /etc/shells':
         path    => '/etc/shells',
         line    => "${boxen::config::homebrewdir}/bin/zsh",
         require => Package['zsh'],
       }

       # Dock Settings
       include osx::dock::autohide
       include osx::dock::clear_dock

       # Screen Zoom
       include osx::universal_access::ctrl_mod_zoom
       include osx::universal_access::enable_scrollwheel_zoom

       # Key Repeat
       class { 'osx::global::key_repeat_delay':
         delay => 10
       }
       include osx::global::key_repeat_rate

       # Capslock becomes Control
       include osx::keyboard::capslock_to_control

       # Hot Corners
       osx::dock::hot_corner { 'Show the desktop':
         position => 'Bottom Right',
         action => 'Desktop'
       }
       osx::dock::hot_corner { 'Put Display to Sleep':
         position => 'Bottom Left',
         action => 'Put Display to Sleep'
       }

       # Recovery Message
       $recovery_owner = "This computer belongs to Jed Northridge."
       $recovery_contact = "If found, please contact jedcn@jedcn.com or 305-985-3326."
       osx::recovery_message { "${recovery_owner} ${recovery_contact}": }
     }
   #+END_SRC

** Dotfiles and Repositories

   I generally use [[https://dotfiles.github.io/][dotfiles]], and I specifically use [[https://github.com/andsens/homeshick][homeshick]] with my
   own [[https://github.com/jedcn/dot-org-files][dot-org-files]].

   In this area, boxen enables you to:

   1. Declare which repositories should be cloned on the
      machine. These don't have to limited to dotfiles, for example, I
      like to have [[https://github.com/robbyrussell/oh-my-zsh/][oh-my-zsh]] and [[https://github.com/rupa/z][z]].
   2. Setup links from your home directory to those repositories.

   Of course, you don't have to use boxen to setup links if the system
   you're using has this capability, but in my case I let boxen do the
   work even though homeshick can handle it.

   I expect that I'll have dozens and dozens of repositories cloned
   onto my machine. My general game plan is to put most of my
   repositories underneath =/project=, and to make a special place for
   repositories that are used to bootstrap my shell (dot files,
   oh-my-zsh, z, etc). These "bootstrap repositories" live underneath
   =/opt/init-src=, which I picked because it's so close to boxen's
   home, =/opt/boxen=.

   I plan on using boxen to only manage the ones at =/opt/init-src=.

   The puppetry below creates a directory, and clones several
   repositories:

   + jedcn/dot-org-files
   + jedcn/emacs-setup
   + robbyrussell/oh-my-zsh
   + rupa/z

   #+BEGIN_SRC puppet :tangle ./modules/people/manifests/jedcn/repositories.pp
     class people::jedcn::repositories {

       $my_init_src = '/opt/init-src'

       file { $my_init_src:
         ensure => directory,
         mode   => 0644,
       }

       repository { "${my_init_src}/dot-org-files":
         source  => 'jedcn/dot-org-files',
         require => File[$my_init_src]
       }

       repository { "${my_init_src}/emacs-setup":
         source  => 'jedcn/emacs-setup',
         require => File[$my_init_src]
       }

       repository { "${my_init_src}/z":
         source  => 'rupa/z',
         require => File[$my_init_src]
       }

       repository { "${my_init_src}/oh-my-zsh":
         source  => 'robbyrussell/oh-my-zsh',
         require => File[$my_init_src]
       }
     }
   #+END_SRC

   And this next puppetry creates several links so that the files
   inside of those repositories appear in places relative to my home
   directory.

   The "require" attributes instruct puppet to make sure the main
   directory and repositories are cloned before the links are created:

   #+BEGIN_SRC puppet :tangle ./modules/people/manifests/jedcn/links.pp
     class people::jedcn::links {

       $my_init_src = '/opt/init-src'

       file { "/Users/${luser}/.zshrc":
         ensure  => link,
         mode    => '0644',
         target  => "${my_init_src}/dot-org-files/home/.zshrc",
         require => Repository["${my_init_src}/dot-org-files"],
       }

       file { "/Users/${luser}/.oh-my-zsh":
         ensure  => link,
         target  => "${my_init_src}/oh-my-zsh",
         require => Repository["${my_init_src}/oh-my-zsh"],
       }

       file { "/Users/${luser}/.slate":
         ensure  => link,
         mode    => '0644',
         target  => "${my_init_src}/dot-org-files/home/.slate",
         require => Repository["${my_init_src}/dot-org-files"],
       }
     }
   #+END_SRC

** Applications

   Next up, after dot-files and repositories have been figured out, we
   figure out applications like Chrome and Firefox.

   You can use boxen to install the applications that you work
   with. In turn, boxen relies on modules to install applications, and
   here are a few examples of modules that I use:

   * [[https://github.com/boxen/puppet-firefox][puppet-firefox]]
   * [[https://github.com/boxen/puppet-chrome][puppet-chrome]]
   * [[https://github.com/boxen/puppet-slate][puppet-slate]]

   After you declare that you want to have an application, like
   firefox, you run the command =boxen= and the application will
   "just" appear in your Applications folder. This means installing
   applications is reduced to writing a few lines of code rather than
   visiting websites, downloading =.dmg= files, and running
   installers.

   However, you still have the ability to install an application
   manually, so which path should you choose?

*** Boxen vs. Manual Install

    Not all puppet-modules are created equally. This is especially so
    when it comes to applications: some of them call out older
    versions of applications. These may no longer work, or there may
    be newer versions available.

    Also, in some cases, you need to install an application via the
    AppStore to get the correctly licensed version of it. This
    happened to me with 1Password.

    And so, I make a choice with each application between using boxen
    vs. installing by hand. In general, if I can get it through boxen,
    that's what I'd prefer.

    After all of that, let's talk about the applications that are
    installed as part of this puppet config.

*** Browsers

    I use the standard set of browsers, and can pull in Chrome,
    Firefox, and their development versions.

*** Window Management

    [[https://github.com/jigish/slate][Slate]] was a game changer for me, and I've written more about it
    here: http://jedcn.com/posts/slate/.

*** Declarations

    Here's the puppetry that handles my applications:

    #+BEGIN_SRC puppet :tangle ./modules/people/manifests/jedcn/applications.pp
      class people::jedcn::applications {
        include chrome
        include chrome::canary
        include firefox
        include slate
      }
    #+END_SRC

** Command Line Utilities

   I get all of my command line utilities from [[http://brew.sh][homebrew]]. Usually if I
   land on a new computer I type a number of =brew install xyz=
   commands, but this puppetry allows me to put all of the packages I
   want in an array, run a single =boxen= command, and then I'm done.

   As I scan through what's below, I recognize that the majority of
   packages are simple, standard installs. It's like you typed =brew
   install ag=, for example.

   However, you can install with options, as I do with emacs with
   options certain options that I learned of in a post titled [[http://emacsredux.com/blog/2013/08/21/color-themes-redux/][Color
   Themes: Redux]] in [[ttp://emacsredux.com][Emacs Redux]].

   As a quick note, Homebrew is the standard package provider for
   puppetry within boxen. This means that if you declare a =package=
   (as seen below) then the =provider= defaults to Homebrew.

   Without further delay, here are the packages I like:

   #+BEGIN_SRC puppet :tangle ./modules/people/manifests/jedcn/homebrew.pp
     class people::jedcn::homebrew {
       $homebrew_packages = [
                             'ag',
                             'tmux',
                             'tree',
                             'wget',
                             'zsh',
                             ]

       package { $homebrew_packages: }

       package { 'cask':
         ensure  => present,
         require => Package['emacs'],
       }

       package { 'emacs':
         ensure          => present,
         install_options => [
           '--cocoa',
           '--srgb'
         ],
       }
     }
   #+END_SRC

** Boxen, Puppetry, and File Layout

   TODO XXX TODO

   I start with a single puppet file: =jedcn.pp=.

   This file declares =people::jedcn=. This knows how to include
   everything, but doesn't know anything on its own.

   #+BEGIN_SRC puppet :tangle ./modules/people/manifests/jedcn.pp
      class people::jedcn {
        include people::jedcn::applications
        include people::jedcn::git
        include people::jedcn::homebrew
        include people::jedcn::links
        include people::jedcn::osx_config
        include people::jedcn::repositories
      }
   #+END_SRC


** How to Get Started with boxen

** Glue Code and Rake Tasks

** Keeping Things Up To Date

** Commands

** Files

   Whenever you run =boxen= the configuration from certain files is
   applied. These files are all puppet files. An explanation and
   manifest follows.

*** jedcn.pp

*** git.pp

    This file declares =people::jedcn::git=.

    This class calls out my git configuration.

    #+BEGIN_SRC puppet :tangle ./modules/people/manifests/jedcn/git.pp
      class people::jedcn::git {
        git::config::global { 'core.editor':
          value  => '/opt/boxen/homebrew/bin/emacsclient'
        }
      }
    #+END_SRC

*** homebrew.pp

** Resources

   My main resource was Gary Larizza's article called "[[http://garylarizza.com/blog/2013/02/15/puppet-plus-github-equals-laptop-love/][Puppet + Github
   = Laptop <3]]" and [[https://github.com/glarizza/my-boxen/][glarizza/my-boxen]].

   Other resources included:

   + The official boxen homepage: https://boxen.github.com
   + [[https://github.com/boxen/our-boxen][boxen/our-boxen]]
   + Visiting https://github.com/boxen/ and then filtering through all
     of the puppet-* projects.
   + http://jjasghar.github.io/blog/2014/01/01/customizing-boxen/

** Ruby and Content Extraction

   This single =.org= file can be extracted into many component
   pieces. This is powered by Emacs and Ruby.

   Some of these pieces are puppetry and some are web files. The two
   main categories are presently:

   + *.pp extraction (for boxen runs)
   + HTML extraction (for building a static, descriptive site)

   As far as Ruby is concerned, the main driver is Rake. And so,
   there's a =Rakefile= and the are supporting =./rakelib/*.rake=

** Rake Basics

   One role played by this file is simple existence: so long as it
   exists, even if it contains no content, the =rake= command can find
   a home and understand the location of =./rakelib=.

   Another role is that it defines common functionality for running
   tasks and a default task.

#+BEGIN_SRC ruby :tangle ./Rakefile
  def run(c)
    require 'open3'
    _stdin, stdout, stderr = Open3.popen3(c)
    [ stdout.gets, stderr.gets, $?.to_i ]
  end

  task :emacs_installed do
    location = `which emacs`
    raise 'Unable to find emacs' if location.empty?
  end

  task default: :tangle
#+END_SRC

** Website

   This document can be unpacked into distinct puppet files that serve
   as configuration. It can also be unpacked into HTML files and Rake
   configuration builds and serves as a website.

   Those files are:

*** rakelib/index.html.erb

    This content started as the index.html associated with the
    Bootstrap version of [[http://html5boilerplate.com/][HTML5BoilerPlate]]. I removed the core content
    and replaced it with ERB. I also added a link to prism.js and css.

#+BEGIN_SRC html :tangle ./rakelib/index.html.erb
  <!DOCTYPE html>
  <!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
  <!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
  <!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
  <!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
      <head>
          <meta charset="utf-8">
          <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
          <title>My Boxen</title>
          <meta name="description" content="">
          <meta name="viewport" content="width=device-width, initial-scale=1">

          <link rel="stylesheet" href="css/bootstrap.min.css">
          <style>
              body {
                  padding-top: 50px;
                  padding-bottom: 20px;
              }
          </style>
          <link rel="stylesheet" href="css/bootstrap-theme.min.css">
          <link rel="stylesheet" href="css/prism.css">
          <link rel="stylesheet" href="css/main.css">

          <script src="js/vendor/modernizr-2.6.2-respond-1.1.0.min.js"></script>
          <script src="js/vendor/prism.js"></script>
      </head>
      <body>
          <!--[if lt IE 7]>
              <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
          <![endif]-->

      <div class="container">

        <%= content %>

        <hr>

        <footer>
          <p>:)</p>
        </footer>
      </div> <!-- /container -->
      </body>
  </html>
#+END_SRC

*** rakelib/ghpages.rake

    This file contains Rake-based instructions for building up static
    web content that serves as a website.

    This static content will be hosted on Github Pages, and so, the
    following makes it so that the directory =gh-pages/= is created
    and the contents of that directory are a single branch from this
    same repository.

    There's also a part that knows about http://www.initializr.com,
    and how to download a copy of HTML5 Boiler Plate. This comes in a
    ZIP. These instructions know how to unpack the ZIP and put parts
    of it in the right places.

    Finally there's a part in here that knows how to extract this
    =.org= file using emacs into HTML and then insert that HTML into
    an ERB enhanced template.

#+BEGIN_SRC ruby :tangle ./rakelib/ghpages.rake
  require 'rake/clean'

  desc 'Create Github Pages content'
  task 'build-gh-pages' => [ 'gh-pages',
                             'gh-pages-supporting-content',
                             'gh-pages/index.html' ]

  #
  # Setup ./gh-pages as a git clone with gh-pages checked out.
  #
  directory 'gh-pages' do
    repo = 'https://github.com/jedcn/my-boxen.git'
    branch = 'gh-pages'
    dir = branch
    args = "#{repo} --branch #{branch} --single-branch ./#{dir}"
    command = "git clone #{args}"
    stdout, stderr, _status = run(command)
    puts stderr, stdout
  end

  #
  # Extract supporting content from HTML5BoilerPlate
  #
  task 'gh-pages-supporting-content' => [ 'gh-pages/favicon.ico',
                                          'gh-pages/css/bootstrap.min.css',
                                          'gh-pages/css/bootstrap-theme.min.css',
                                          'gh-pages/js/vendor/modernizr-2.6.2-respond-1.1.0.min.js' ]

  def add_option(url, s)
    "#{url}&#{s}"
  end

  CLEAN.include('gh-pages/initializr.zip')
  CLEAN.include('gh-pages/initializr')
  file 'gh-pages/initializr' do
    chdir('gh-pages') do
      `wget -O initializr.zip 'http://www.initializr.com/builder?boot-hero&jquerymin&h5bp-iecond&h5bp-chromeframe&h5bp-analytics&h5bp-favicon&h5bp-appletouchicons&modernizrrespond&izr-emptyscript&boot-css&boot-scripts'`
      `unzip initializr.zip`
    end
  end

  #
  # Setup files from HTML5BoilerPlate
  #
  def cp_from_initializr(file, dir)
    dest =
      if dir
        "gh-pages/#{dir}"
      else
        'gh-pages'
      end
    FileUtils.cp("gh-pages/initializr/#{file}", dest, verbose: true)
  end

  file 'gh-pages/favicon.ico' => 'gh-pages/initializr' do
    cp_from_initializr('favicon.ico')
  end

  directory 'gh-pages/css' => 'gh-pages'
  directory 'gh-pages/js' => 'gh-pages'
  directory 'gh-pages/js/vendor' => 'gh-pages/js'

  file 'gh-pages/favicon.ico' => 'gh-pages/initializr' do
    cp_from_initializr('favicon.ico')
  end

  file 'gh-pages/css/bootstrap.min.css' => 'gh-pages/css' do
    cp_from_initializr('css/bootstrap.min.css', 'css')
  end

  file 'gh-pages/css/bootstrap-theme.min.css' => 'gh-pages/css' do
    cp_from_initializr('css/bootstrap-theme.min.css', 'css')
  end

  file 'gh-pages/js/vendor/modernizr-2.6.2-respond-1.1.0.min.js' =>
       'gh-pages/js/vendor' do
    cp_from_initializr('js/vendor/modernizr-2.6.2-respond-1.1.0.min.js',
                       'js/vendor')
  end

  directory 'gh-pages/css' => 'gh-pages'

  file 'README.html' => :emacs_installed do
    export_html_using_emacs('README.org')
  end

  file 'gh-pages/index.html' => [ 'gh-pages', 'README.html' ] do

    require 'erb'
    require 'ostruct'

    class ContentWrapper < OpenStruct
      def render(template)
        ERB.new(template).result(binding)
      end
    end

    template = File.read('rakelib/index.html.erb')

    content = File.read('README.html')

    cw = ContentWrapper.new({ content: content })
    File.open('gh-pages/index.html', 'w') do |file|
      file.write(cw.render(template))
    end

    rendered = File.read('gh-pages/index.html')
    s = "<pre>\n<code class='language-ruby'>"
    rendered = rendered.gsub('<pre class="src src-puppet">', s)
    rendered = rendered.gsub('</pre>', '</code></pre>')
    File.open('gh-pages/index.html', 'w') do |file|
      file.write(rendered)
    end
    rm 'README.html', verbose: true
  end

  def export_html_using_emacs(file)
    args = '--no-init-file --no-site-file --batch'
    tangle_elisp =
      %Q|(progn (require 'org) (find-file (expand-file-name \\"#{file}\\" \\"`pwd`\\")) (org-html-export-to-html nil nil nil t))|
    command = %Q|emacs #{args} --eval "#{tangle_elisp}"|
    stdout, stderr, _status = run(command)
    puts stderr
    puts stdout
  end
#+END_SRC

** Tangling Puppet

   A series of puppet files can be extracted from this document. This
   works by invoking emacs in batch mode. Some small emacs lisp is
   passed in via the command line, and that emacs lisp works with
   org-babel to extract files in place.

#+BEGIN_SRC ruby :tangle ./rakelib/tangle.rake
  def tangle_file_using_emacs(file)
    args = '--no-init-file --no-site-file --batch'
    tangle_elisp =
      %Q|(progn (require 'ob-tangle) (org-babel-tangle-file \\"#{file}\\"))|
    command = %Q|emacs #{args} --eval "#{tangle_elisp}"|
    _stdout, stderr, status = run(command)
    puts stderr unless status == 0
  end

  desc 'tangle literate source into puppet'
  task :tangle => :emacs_installed do
    tangle_file_using_emacs('README.org')
  end
#+END_SRC

** Staying up-to-date with boxen/our-boxen

   This repository is a fork of [[https://github.com/boxen/our-boxen][boxen/our-boxen]], and so, while I've
   done a bunch of customization, I'd like to stay up-to-date with the
   original repository to get fixes, security patches, etc.

   This is setup by creating a remote named "upstream" that points to
   [[https://github.com/boxen/our-boxen][boxen/our-boxen]]. Then the master branch from this repo is merged in
   like regular.

   The directions are here: [[https://help.github.com/articles/syncing-a-fork/][github.com/articles/syncing-a-fork/]].

** Manual Installs

   I installed the following Software manually:

*** 1Password

    I got this from the AppStore. I did because I couldn't figure out
    how to license it, otherwise.

*** Little Snitch

    I tried installing this via puppet. I tried a provider of =appdmg=
    and =pkgdmg=, and neither did I was expected. I started with
    =appdmg=, and this put both the Installer and Uninstaller in my
    Applications-- but that's not what I want. I want to run the
    Installer *once* and then have "Little Snitch Configuration" be
    the only thing that's in my Applications.

    Anyway-- I gave up and I downloaded it from this URL and
    double-clicked to the install:

    http://www.obdev.at/downloads/littlesnitch/LittleSnitch-3.5.1.dmg

    The install required a reboot, and after that, it immediately
    started going.

** Oddities and Troubleshoot

*** 1Password and Licensing

    I tried getting onepassword here (with [[https://github.com/boxen/puppet-onepassword][puppet-onepassword]]), but I
    couldn't figure out the licensing. Specifically, after a boxen run
    it was in trial mode and looking for a license file. But, I didn't
    have a license because I bought 1Password through the
    AppStore.

    After 15 minutes of mucking around, I installed through the
    AppStore, and things worked just fine.

*** Given up on a Module Failed Installations

    Near as I can tell, if you try to get something running with boxen
    and then you give up and remove the puppetry, you'll still have
    whatever-didnt-install-the-way-you-wanted installed, and so, you
    can manually remove that thing but you should also remove
    something called a "receipt" that can be found in the =/var/db=
    directory, for example:

    + =sudo rm .puppet_compressed_app_installed_1Password\ 5=
    + =sudo rm /var/db/.puppet_appdmg_installed_LittleSnitch=

    I learned about receipts in the [[https://github.com/boxen/our-boxen/blob/master/docs/faq.md][official boxen FAQ]].

*** What does a module do?

    If you've found a puppet module that you'd like to check out, the
    first place to look is in the file named =manifests/init.pp=. I
    believe this is the entry point for all modules. You can usually
    see other files that are included into it or URLs, version
    numbers, and configuration options.

*** Where do you find modules?

    Modules can be defined anywhere, and the most popular ones are
    underneath the Boxen Github repository:
    https://github.com/boxen/.

    You can search for ones that are formally part of that
    organization by visiting the link above and typing the name of the
    application into to the "Filters."

*** Starting on machine without boxen?

    The commands you'd run on a fresh Mac are:

    #+BEGIN_SRC sh
      xcode-select --install
      sudo mkdir -p /opt/boxen
      sudo chown ${USER}:staff /opt/boxen
      git clone https://github.com/jedcn/my-boxen /opt/boxen/repo
      /opt/boxen/repo/script/boxen
    #+END_SRC

    These commands:

    1. Install xcode (which gets you a compiler: gcc)
    2. Clone my-boxen configuration to /opt/boxen/repo
    3. Invoke boxen which reads my-boxen configuration and sets up the
       machine.

*** Starting on a machine that has boxen?

    If you've already setup your Mac, you can change your boxen
    configuration and run =boxen= to see those changes realized. This
    can be completed in as short as 10 seconds.
